# TechCore

> Core systems and architecture for city-building strategy concept (work‑in‑progress)

> Tech Stack: Zenject, UniRx, UniTask, Addressables, Firebase (Analytics, Remote configs), DOTween, Newtonsoft.Json
---

## About

Этот проект разработан как основа для небольшой стратегии с длительным циклом разработки и поддержки. Акцент был сделан на попытке выстроить внятную архитектуру с которой было бы приятно развивать проект дальше. Проектирование было основано на принципах модульности и слабой связанности, с чётким разделением ответственности между слоями: представление, логика, хранение и инфраструктура (в целом придерживаясь SOLID, DRY, KISS без фанатизма). Используется MVVM-подход и реактивная модель. 

<p align="center">
  <img src="./media/gameplay_part1.gif" alt="Gameplay Part 1" width="320" style="margin-right:10px;">
  <img src="./media/gameplay_part2.gif" alt="Gameplay Part 2" width="320">
</p>

---

## Table of Contents

- [Game Loop](#game-loop)
- [Gameplay Interaction Flow](#gameplay-interaction-flow)
- [Gameplay Simulation Flow](#gameplay-simulation-flow)
- [Data Flow (CQRS-light)](#data-flow)
- [Building System Flow](#building-system-flow)
- [Resource System](#resource-system)
- [UI System & Screen Management](#ui-system--screen-management)
- [Infrastructure & Services](#infrastructure--services)
  
---

## Architecture Overview
### Game Loop
Было решено не изобретать велосипед поэтому за общий игровой цикл отвечает FSM. У нее есть глобальные и сценозависимые состояния. После загрузки сцены срабатывает SceneInstaller, который после всех биндингов создает SceneEntryPoint. SceneEntryPoint, в свою очередь, регистрирует состояния для данной сцены и запускает первое из них. При выгрузке сцены очищаем FSM от сценозависимых состояний. 

<p align="center">
  <img src="./docs/GameLoop.svg" width="1920" alt="Architecture Diagram" />
</p>

---

### Gameplay Interaction Flow

`GameplayState` запускает вложенную state-машину, отвечающую за геймплейные состояния.  
Каждое состояние определяет, какие фичи активны и какие реакции на ввод допустимы.

Ввод делится на два типа:
- **UI-ввод**: инициируется `ViewModel` и передаётся через `SignalBus` (только ключевые команды, напрямую влияющие на игровое состояние)
- **Взаимодействие с игровым миром**: обрабатывается через `InputService` и `IInputHandler`
  (например, управление камерой, сбор ресурсов, взаимодействие со зданиями)

Геймплейные состояния (`Default`, `PlaceBuilding` и др.) действуют как связующее звено между вводом и логикой: каждое из них подписывает нужные обработчики, а при выходе — отписывает. Некоторые состояния также инкапсулируют полноценные пользовательские сценарии (например, размещение зданий).

Таким образом обеспечивается изоляция логики и гибкое управление поведением в зависимости от контекста.

<p align="center">
  <img src="./docs/GameplayInteractionFlow.svg" width="1920" alt="Architecture Diagram" />
</p>

---

### Gameplay Simulation Flow

`GameplayState` запускает внутреннюю активную игровую логику через `GameplayPhaseFlow`. К этому моменту весь игровой мир уже создан и проинициализирован, его остается только запустить. 

Здания и их модули начинают выполнять автономную логику: потребляют и генерируют ресурсы, проверяют условия, взаимодействуют с миром. Условия модулей валидируются в реальном времени и влияют на выполнение логики. Параллельно запускаются игровые события. Они активируются через `LiveEventsService` и динамически влияют на состояние мира и поведение систем.

UI-слой наблюдает за ViewModel'ями и реактивно отображает все изменения: индикаторы, события, попапы, бары и другие визуальные элементы автоматически отражают текущее состояние мира.

<p align="center">
  <img src="./docs/GameplaySimulationFlow.svg" width="1920" alt="Architecture Diagram" />
</p>

---

### Data Flow (CQRS-light)

Архитектура разделяет запись и чтение. Минимизируем состояние в сохранениях, держим вычислимое в рантайме, правила — в конфигах. 
Можем выделить 4 источника данных:
- **Persistent**: минимальный набор состояния, сохраняемый между сессиями. Хранится в json с сохранением абстракций. Доступ на запись только через команды.  
- **Configs**: статичные данные. Поставляются через `Addressable`.  
- **Runtime**: живёт только во время сессии, всегда можно воссоздать из `Persistent + Configs`. Чтение/запись напрямую доменом.
- **RemoteConfigs**: патчат статические конфиги в рантайме.
 
`Write-path`
Игровая логика формирует команды. Обработчики команд (Unity-agnostic) собирают `DecisionContext` (необходимые persistent/runtime/config данные) -> валидируют условия выполнения -> вызывают `Mutators` для переиспользуемых сценариев (набор write-операций с чёткими инвариантами) или напрямую атомарно пишут в модель -> модели обновляют чистые данные (фактически являясь реактивными обертками над ними). 

`Read-path`
Чтение через Queries и Subscriptions.
`Queries` - чистые проекции над runtime/persistent/configs, параметризуемые игровой логикой, которые возвращают иммутабельный snapshot «правды о мире». `Subscriptions` - реактивные проекции тех же данных для UI и логики которая в этом нуждается. 

`Save-flow`
При сохранении SaveService извлекает чистые данные из ProgressService и передает их в StorageService. 

<p align="center">
  <img src="./docs/DataFlow.svg" width="1920" alt="Architecture Diagram" />
</p>

---

### Building System Flow

Здания — центральная сущность игрового процесса, связывающая доменную логику, UI и реактивные данные. Их жизненный цикл начинается с запроса на размещение и запуском логики в рамках игровой фазы.

Запрос на размещение исходит из `PlaceBuildingState` который проверяет условия, `BuildingService` (в данном случае фасад для `PlaceBuildingCommand`) отправляет команду, обработчик валидирует и записывает здание в прогресс.

`BuildingRepository` реагирует на изменения данных и через `BuildingFactory` создаёт View и ViewModel. Затем `BuildingService` регистрирует здание в `GameplayPhaseFlow` и подключает его к UI через сервисный UI слой. Удаление проходит по той же цепочке.

`BuildingView` отвечает за визуал, `BuildingViewModel` -  фасад и координатор здания: инициализирует модули, связывает их с данными, агрегирует состояния и маршрутизирует запросы, оставляя игровую логику внутри модулей. 

Модули — это независимые функциональные блоки. Они определяют принципы работы здания. Каждый модуль может конфигурироваться набором условий разных типов которые влияют на сам модуль или на все здание. Для игрока эта внутренняя логика отображается через индикаторы с приоритетом. Условия и модули могут предоставлять собственные индикаторы, которые `ViewModel` агрегирует и позволяет читать UI слою `BuildingIndicatorsViewModel`.

Взаимодействие с зданием происходит через систему `BuildingActions`. Каждый модуль может объявлять свои действия, которые ViewModel агрегирует и отдает по запросу `BuildingActionsBar` если здание выделено. Когда игрок кликает на здание, `ActionBar` показывает доступные действия в виде кнопок UI, а при нажатии запускает связанную с модулем логику. Таким образом, `Action` служит мостом между UI и внутренней функциональностью модуля.

Архитектура построена так, чтобы легко расширять систему. На уровне `BuildingFactory` происходит настройка статическими данными, в `BuildingRepository` — инициализация прогресс-данными, а в `GameplayPhaseFlow` — запуск логики в зависимости от фазы игры. 

Конкретные типы модулей и условий определяются в конфиге, и только там известно, как их создать и настроить. В коде остаются лишь абстракции, что позволяет добавлять новые виды зданий, модулей и условий без изменения ядра.

<p align="center">
  <img src="./docs/BuildingSystem.svg" width="1920" alt="Architecture Diagram" />
</p>

---

### Resource System 

Ресурсы — базовая валюта действий. Ключевая цель — предсказуемость операций, отсутствие скрытых побочных эффектов и гонок данных.

Источник истины для чтения — поведение ресурса (`IResourceBehaviour`) за которым стоит агрегатор (`IResourceQuery`) поверх persistent+runtime. Механика ресурсов построена декораторно. Более сложные возможности оборачивают простые, не ломая инварианты и API.

Любая мутация атомарна и детерминистична. Взаимодействие потоков защищено от реэнтрантности (`SyncLatestReactiveProperty` + валидация на уровне решений). В режимах: strict — операция отклоняется, если условий недостаточно, flexible — объём автоматически клипуется к доступному.

Запись в прогресс происходит по следующему сценарию: домен инициирует действие -> применяются рантайм-модификаторы -> формируется команда в `ResourceService` -> уходит в handler -> handler делегирует в `ResourceMutator` (единая «точка истины» по правилам ресурсов) -> `ResourceMutator` берёт снимок из `IResourceQuery`, валидирует по режиму (Strict/Flexible) и атомарно выполняет списание/добавление (обмен — как составная атомарная операция). Полностью без аллокаций. 

Временные состояния меняются тоже через `ResourceService`, который делегирует вызов в поведение ресурса. Так работают резервы которые создаются через TryReserve и возвращают токен для контроля жизненного цикла. Освобождение ресурса происходит по токену либо автоматически поведением. Runtime-бонусы (например, от зданий) так же не сохраняются и пересчитываются при загрузке.

Источником ресурсов может быть как само производсво, так и динамическое событие. Например, метеоритный дождь, где метеорит задаёт только тип дропа и его координаты, а финальное содержимое формируется при обработке команды на основе статических данных и детерминированного seed. Такой дроп сохраняет состояние между сессиями и может быть собран `ResourceCollector`. Успешный сбор проходит стандартный путь через `ResourceService` и публикует доменное событие, на которое подписан `ResourceFlyTextUiEffect`, создающий соответствующий UI-эффект в точке подбора.

---

### UI System & Screen Management

UI — MVVM. View отвечает за визуализацию и локальные эффекты, ViewModel собирает реактивные данные (стримы + снапшоты), агрегирует состояние и решает, что и когда показать.

Источники данных для UI — реактивные потоки из сервисов и механик, чистые снапшоты и доменные события. Обратная связь вверх идёт короткими путями: либо высокоуровневые сигналы (чтобы не тянуть цепочки), либо вызовы команд уровня Application для конкретных пользовательских сценариев. Слой Application не знает о конкретных вьюхах — он лишь запрашивает показ окон через Window/Popup-сервисы.

Окна и попапы управляются централизованно: фабрики создают и подключают префабы, инжектят VM, ведут кэш (без дублей и гонок при параллельных вызовах), слой сервисов держит жизненный цикл. Это даёт единое поведение для всего UI: окно открывается предсказуемо, закрывается корректно, переиспользуется там, где можно. 

Композиция экрана - одна View может управлять группой простых под-view: создаёт/переставляет их, подписывает на минимальные потоки, освобождает по жизненному циклу.

Привязка к миру — единая проекция world → screen → canvas. Индикаторы зданий, всплывающие значения ресурсов и иконки подтверждения следуют за объектами с учётом позиции камеры. Визуальный отклик через DoTween анимации. 

Частые элементы — из пула, префабы/VM кэшируются, тяжёлые вычисления статического лэйаута считаются один раз на старте под текущее соотношение сторон, дальше layout-компоненты отключены.

HUD — фасад экрана. В нём живут панель действий здания, события, нотификации, ресурсная полоса. Подсистемы независимы (свои VM и источники данных), но подчиняются общим правилам показа, позиционирования и открытия окон через сервисы — без прямых связей между экранами.

---

### Infrastructure & Services

#### SaveService

`CodeBase\Infrastructure\Services\SaveService`

Есть ручной сейв и автосейв который привязан к потоку playtime. Сохранение происходит в специльно выделенные слоты.  
Запись атомарная (`tmp→backup→save`) с откатом при I/O-ошибках, операции последовательно проходят через `SemaphoreSlim` с таймаутом. Метаданные сохраняются отдельно в .meta, список слотов собирается из .meta и сортируется по времени. Есть слабый кэш загруженных состояний, чтобы не парсить JSON повторно.  
Десериализация защищена: белый список типов и проверка generic-аргументов на принадлежность доверенным сборкам, словари с ключами Type сериализуются через `AssemblyQualifiedName`.   
Публичный API предельно узкий (`SaveManualAsync`); результат загрузки — статус + слепок; слоты фиксированы (Auto/Quick/Manual1…10). 

---

#### Addressables: assets & configs 

`CodeBase\Infrastructure\Services\AssetsPipeline`

Система построена вокруг обёртки `AssetProvider`, которая даёт единообразный доступ к `Addressables` с готовностью, кешированием по ключу (адрес или guid + тип), возможностью предзагрузки по label и повторными попытками при ошибках, а также корректным Release и массовой очисткой handle. Решает двойные загрузки и гонки при старте.  
Поверх этого StaticDataProvider загружает все конфиги пакетами по label, патчит их через `Remote Config`, а затем индексирует нужные данные для быстрого доступа. Последовательность: ждать `AssetProvider.WhenReady` → скачать → дождаться патчера → применить патчи → проиндексировать.  
Для исключения «магических строк» в коде используем мапперы. 

---

#### Analytics (Firebase)

`CodeBase\Services\AnalyticsService`

Аналитика стартует через `FirebaseBootstrap`: по умолчанию используется заглушка `NoneAnalyticsService`, которая после успешной инициализации подменяется на `FirebaseAnalyticsService`. Доступ наружу идёт через прокси — до готовности `Firebase` все вызовы буферизуются и отправляются после подключения. События логируются в `FirebaseAnalyticsService` с типобезопасной упаковкой параметров, а ключи централизованы. Данные для аналитики поступают через сигналы (`EventBus`) и обрабатываются трекерами, каждый из которых сам определяет, что, как и когда отправлять.

---

#### Remote Configs (Firebase)

`CodeBase\Services\RemoteConfigsService`

Аналогичнко с аналитикой ждем инициализации, подставляем нужную реализацию, выставляем готовность `_whenReadyTcs.Task.WithCycleGuard(this)` для тех, кто ждет данный сервис.  
Сам `FirebaseRemoteConfigService` подгружает файл с дефолтными значениями (`RemoteConfigDefaults`) через `AssetProvider`, чтобы у игры всегда были fallback-параметры. Дальше делает Fetch и Activate, обновляя значения на лету. Система умеет работать с простыми типами и enum.   
Данные из `Remote Config` в проекте используются двумя способами. Первый — автопатчинг через `RemoteConfigPatcher`: он находит в `ScriptableObject` поля с атрибутом `[RemoteKey]` и автоматически подставляет туда актуальные значения из конфигов. Второй — явное чтение и разбор, когда конфиг нужен в особом формате.

---

#### Live Events

`CodeBase\Gameplay\LiveEvents`

`LiveEvents` — data-driven «лента» событий из `Remote Config`. Cервис ждёт готовности конфигов и времени, подписывается на серверный `CurrentTime`, по реестру (ключ RC + тип данных -> тип события) создаёт инстансы через DI-фабрику, регистрирует их в фазовом потоке, сортирует по старту и на каждом тике обновляет активность, публикуя ленту событий. 
База (`GameEventBase`) парсит время в UTC, держит реактивные стримы статуса и таймингов, и триггерит события при входе/выходе из окна активности.   
Из коробки: `MeteorShowerEvent` рулит спавнером метеоритов с множителем из данных, а `ProductionBoostEvent` добавляет/снимает ресурсный модификатор на время ивента.   
Синхронизация идёт по серверному времени (fallback — локальное).

---

#### Grid System: map & placement

`CodeBase\Gameplay\Services\Grid`

`GridPlacement` преобразует координаты в мировые, снапит позиции с учётом размеров и генерирует набор целевых клеток, помечая их доступность через валидаторы. Формирует запрос на размещение.  
Занятость отслеживается в `GridOccupancyQuery`, который инициализируется данными карты и прогресса, реактивно обновляется при изменениях и даёт быстрые проверки по маскам и фильтрам. Карта «пекётся» заранее из маркеров в GameMap (`MapEntityData`). Статусы клеток (`CellData, CellStatus`) унифицированы и хранят флаги зданий, участков, ресурсов и препятствий, обеспечивая быстрые операции добавления, удаления и проверки.

---

#### Input System

`CodeBase\Services\InputService` & `CodeBase\Gameplay\InputHandlers`

`Input Handlers` — это слой, через который игровые состояния подписываются на пользовательский ввод. Центральная точка — `InputService`: он слушает `InputSystemActions` и `TapDetector`, который работает в фоне, отслеживая быстрые касания по длительности и смещению, и генерирует сигнал для `InputService`. Затем InputService рассылает события ввода всем активным `PlayerInputHandler`. При подписке можно использовать `InputHandlerWithUiFilter`, который пропускает ввод только если курсор не над UI.

Каждый `PlayerInputHandler` реализует свою реакцию на события и активируется состоянием, которое его подписывает. Подход позволяет в любой момент включать и выключать нужные обработчики в зависимости от текущего состояния игры, изолируя их логику и предотвращая конфликты за ввод.

---

#### Factories

Фабрики — единая точка сборки: по конфигам и адресам загружают префабы, создают объекты через DI, связывают View-ViewModel и, где нужно, собирают модульный состав.   
Работаю по общему принципу cache-or-create: сперва кэш/пул — иначе загрузка и регистрацияю. Плюс организационные штуки вроде root-объектов для групп, async-инициализаций и защиты от параллельных дублей.

---

#### Object Pools

`CodeBase\Gameplay\Services\Pool`

Система пулов — это обобщённый `ObjectPool`, который подписывается на Deactivated и автоматически возвращает элементы в очередь с опциональным Reset, минимизируя аллокации. `MappedObjectPool` группирует пулы по ключу для разных типов объектов, а интерфейсы `IPoolItem/IResettablePoolItem` задают контракт активации и сброса. Параметры активации передаются через generic или `PoolUnit` по умолчанию.

